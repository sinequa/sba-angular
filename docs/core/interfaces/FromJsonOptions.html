<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Core</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">Core</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>FromJsonOptions</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>base/utils.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Describes options for the <a href="../classes/Utils.html#fromJson">Utils.fromJson</a> method</p>

            </p>


        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#reviveDates">reviveDates</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="reviveDates"></a>
                                        <span class="name"><b>reviveDates</b><a href="#reviveDates"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>reviveDates:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>If <code>true</code> then strings containing either ISO8601 or Sinequa &quot;system&quot; dates (<code>yyyy-mm-dd [hh:mm:ss]</code>) are
converted to Javascript <code>Date</code> objects</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {HttpParams, HttpParameterCodec} from &quot;@angular/common/http&quot;;
import {Observable, Subscription} from &quot;rxjs&quot;;
import moment from &quot;moment&quot;;
import {remove as removeDiacritics} from &quot;diacritics&quot;;
import jsSHA from &quot;jssha&quot;;
import {MapOf} from &quot;./map-of&quot;;
import {FieldValue} from &quot;./field-value&quot;;
import kebabCase from &quot;lodash/kebabCase&quot;;
import snakeCase from &quot;lodash/snakeCase&quot;;
import camelCase from &quot;lodash/camelCase&quot;;
import escape from &quot;lodash/escape&quot;;
import unescape from &quot;lodash/unescape&quot;;
import isEqual from &quot;lodash/isEqual&quot;;

// Because of: https://github.com/angular/angular/issues/18261
class SqHttpParameterCodec implements HttpParameterCodec {
    encodeKey(key: string): string {
        return encodeURIComponent(key);
    }

    encodeValue(value: string): string {
        return encodeURIComponent(value);
    }

    decodeKey(key: string): string {
        return decodeURIComponent(key);
    }

    decodeValue(value: string): string {
        return decodeURIComponent(value);
    }
}

/**
 * Describes options for the [Utils.toJson]{@link Utils#toJson} method
 */
export interface ToJsonOptions {
    /**
     * If &#x60;true&#x60; then spacing is added to the output string
     */
    pretty?: boolean;
}

/**
 * Describes options for the [Utils.fromJson]{@link Utils#fromJson} method
 */
export interface FromJsonOptions {
    /**
     * If &#x60;true&#x60; then strings containing either ISO8601 or Sinequa &quot;system&quot; dates (&#x60;yyyy-mm-dd [hh:mm:ss]&#x60;) are
     * converted to Javascript &#x60;Date&#x60; objects
     */
    reviveDates?: boolean;
}

/**
 * Describes options for the [Utils.throttle]{@link Utils#throttle} method
 */
export interface ThrottleSettings {
    /**
     * Set to &#x60;false&#x60; to disable the initial call to the callback function
     */
    leading?: boolean;
    /**
     * Set to &#x60;false&#x60; to disable the final call to the callback function
     */
    trailing?: boolean;
}

class FrameTask {
    constructor(
        public callback: (...params) &#x3D;&gt; any,
        public params: any[]) {
    }

    call(): any {
        return this.callback(...this.params);
    }
}

/**
 * A utility class to log execution durations
 */
export class Timer {
    /**
     * Contains the timestamp of when the &#x60;Timer&#x60; object was instantiated
     */
    readonly start &#x3D; performance.now();
    /**
     * Contains the current durartion in milliseconds of the &#x60;Timer&#x60; object
     */
    duration &#x3D; 0;

    constructor(private readonly name: string) {
    }

    /**
     * Updates the &#x60;duration&#x60; of the &#x60;Timer&#x60; object
     */
    stop() {
        this.duration &#x3D; performance.now() - this.start;
        console.log(&#x60;Timer: ${this.name} finished in ${Math.round(this.duration)} ms&#x60;);
    }
}

/**
 * A utility class containing a variety of static methods and properties
 */
// @dynamic
export class Utils {
    /**
     * The number of milliseconds in one day
     */
    static readonly oneDay &#x3D; 86400000;
    /**
     * The number of milliseconds in one hour
     */
    static readonly oneHour &#x3D; 3600000;
    /**
     * The number of milliseconds in one minute
     */
    static readonly oneMinute &#x3D; 60000;
    /**
     * The number of milliseconds in one second
     */
    static readonly oneSecond &#x3D; 1000;

    private static baseExtend(dst, objs, deep?: boolean, sort?: boolean | ((a: string, b: string) &#x3D;&gt; number)) {
        for (let i &#x3D; 0, ii &#x3D; objs.length; i &lt; ii; ++i) {
            const obj &#x3D; objs[i];
            if (!Utils.isObject(obj) &amp;&amp; !Utils.isFunction(obj)) {
                continue;
            }
            let keys &#x3D; Object.keys(obj);
            if (sort) {
                if (Utils.isFunction(sort)) {
                    keys &#x3D; keys.sort(sort);
                }
                else {
                    keys &#x3D; keys.sort();
                }
            }
            for (let j &#x3D; 0, jj &#x3D; keys.length; j &lt; jj; j++) {
                const key &#x3D; keys[j];
                const src &#x3D; obj[key];
                if (deep &amp;&amp; Utils.isObject(src)) {
                    if (Utils.isDate(src)) {
                        dst[key] &#x3D; new Date(src.valueOf());
                    }
                    else if (Utils.isRegExp(src)) {
                        dst[key] &#x3D; new RegExp(src);
                    }
                    else if (src.nodeName) {
                        dst[key] &#x3D; src.cloneNode(true);
                    }
                    else {
                        if (!Utils.isObject(dst[key])) {
                            dst[key] &#x3D; Utils.isArray(src) ? [] : {};
                        }
                        Utils.baseExtend(dst[key], [src], true);
                    }
                }
                else {
                    dst[key] &#x3D; src;
                }
            }
        }
        return dst;
    }

    /**
     * Shallowly copy the properties in the source objects to the destination object.
     * Any nested objects or arrays will be copied by reference, not duplicated.
     * The source objects are treated in order so properties in later
     * objects will override properties in earlier ones.
     *
     * @param destination The object to which properties are copied
     * @param sources Objects from which properties are copied
     * @return the destination object
     */
    static extend(destination: any, ...sources: any[]): any {
        return Utils.baseExtend(destination, sources, false);
    }

    /**
     * Deeply copy the properties in the source objects to the destination object.
     * Any nested objects or arrays will be duplicated.
     * The source objects are treated in order so properties in later
     * objects will override properties in earlier ones.
     *
     * @param destination The object to which properties are copied
     * @param sources Objects from which properties are copied
     * @return the destination object
     */
    static merge(destination: any, ...sources: any[]): any {
        return Utils.baseExtend(destination, sources, true);
    }

    /**
     * Deeply copy the properties in the source objects to the destination object.
     * Any nested objects or arrays will be duplicated.
     * The source objects are treated in order so properties in later
     * objects will override properties in earlier ones.
     * The properties of the source objects are sorted in ascending, ASCII character order
     * before they are copied to ensure a consistent insertion order in the destination
     * object.
     *
     * @param destination The object to which properties are copied
     * @param sources Objects from which properties are copied
     * @return the destination object
     */
    static mergeAndSort(destination: any, ...sources: any[]): any {
        return Utils.baseExtend(destination, sources, true, true);
    }

    private static forEach(obj, iterator, context?) {
        let key, length;
        if (obj) {
            if (Utils.isFunction(obj)) {
                for (key in obj) {
                    // Need to check if hasOwnProperty exists,
                    // as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function
                    if (key !&#x3D;&#x3D; &#x27;prototype&#x27; &amp;&amp; key !&#x3D;&#x3D; &#x27;length&#x27; &amp;&amp; key !&#x3D;&#x3D; &#x27;name&#x27; &amp;&amp; (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                    iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (Utils.isArray(obj) || Utils.isArrayLike(obj)) {
                const isPrimitive &#x3D; typeof obj !&#x3D;&#x3D; &#x27;object&#x27;;
                for (key &#x3D; 0, length &#x3D; obj.length; key &lt; length; key++) {
                    if (isPrimitive || key in obj) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (obj.forEach &amp;&amp; obj.forEach !&#x3D;&#x3D; Utils.forEach) {
                obj.forEach(iterator, context, obj);
            } else if (Utils.isBlankObject(obj)) {
                // createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty
                for (key in obj) {
                    iterator.call(context, obj[key], key, obj);
                }
            } else if (typeof obj.hasOwnProperty &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
                // Slow path for objects inheriting Object.prototype, hasOwnProperty check needed
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                    iterator.call(context, obj[key], key, obj);
                    }
                }
            } else {
            // Slow path for objects which do not have a method &#x60;hasOwnProperty&#x60;
            for (key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    iterator.call(context, obj[key], key, obj);
                }
            }
            }
        }
        return obj;
    }

    /**
     * Makes a deep copy of the passed object or array and returns it.
     * Copies of source objects of the following types: &#x60;TypedArray&#x60;, &#x60;Date&#x60;, &#x60;RegExp&#x60; &#x60;Node&#x60; are
     * made using the appropriate constructor. Arrays are created using &#x60;[]&#x60;. Other objects are created
     * using &#x60;Object.create&#x60; passing the source object&#x27;s protptype, if any.
     *
     * @param source The source item to copy (&#x60;Object&#x60;, &#x60;Array&#x60;, &#x60;TypedArray&#x60;, &#x60;Date&#x60;, &#x60;RegExp&#x60;, &#x60;Node&#x60;)
     * @param destination An optional item to use as the destination. If passed, the item is cleared
     * before the source is copied to it. The destination cannot be a &#x60;TypedArray&#x60; and cannot be the same
     * as the source
     * @return The copied item
     */
    static copy&lt;T extends object&gt;(source: T, destination?: T): T {
        const stackSource: object[] &#x3D; [];
        const stackDest: object[] &#x3D; [];

        if (destination) {
            if (Utils.isTypedArray(destination)) {
                throw new Error(&quot;Can&#x27;t copy! TypedArray destination cannot be mutated.&quot;);
            }
            if (source &#x3D;&#x3D;&#x3D; destination) {
                throw new Error(&quot;Can&#x27;t copy! Source and destination are identical.&quot;);
            }

            // Empty the destination object
            if (Utils.isArray(destination)) {
                (destination as Array&lt;any&gt;).length &#x3D; 0;
            }
            else {
                Utils.forEach(destination, (value, key) &#x3D;&gt; {
                    if (!source.hasOwnProperty(key)) {
                        delete destination[key];
                    }
                });
            }

            stackSource.push(source);
            stackDest.push(destination);
            return copyRecurse(source, destination);
        }

        return copyElement(source);

        function copyRecurse(source, destination) {
            let key;
            if (Utils.isArray(source)) {
                for (let i &#x3D; 0, ii &#x3D; source.length; i &lt; ii; i++) {
                    destination.push(copyElement(source[i]));
                }
            } else if (Utils.isBlankObject(source)) {
                // createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty
                for (key in source) {
                    destination[key] &#x3D; copyElement(source[key]);
                }
            } else if (source &amp;&amp; typeof source.hasOwnProperty &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
                // Slow path, which must rely on hasOwnProperty
                for (key in source) {
                    if (source.hasOwnProperty(key)) {
                        destination[key] &#x3D; copyElement(source[key]);
                    }
                }
            } else {
                // Slowest path --- hasOwnProperty can&#x27;t be called as a method
                for (key in source) {
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                        destination[key] &#x3D; copyElement(source[key]);
                    }
                }
            }
            return destination;
        }

        function copyElement(source) {
            // Simple values
            if (!Utils.isObject(source)) {
                return source;
            }

            // Already copied values
            const index &#x3D; stackSource.indexOf(source);
            if (index !&#x3D;&#x3D; -1) {
                return stackDest[index];
            }

            if (Utils.isWindow(source)) {
                throw new Error(&quot;Can&#x27;t copy! Making copies of Window instances is not supported.&quot;);
            }

            let needsRecurse &#x3D; false;
            let destination;

            if (Utils.isArray(source)) {
                destination &#x3D; [];
                needsRecurse &#x3D; true;
            } else if (Utils.isTypedArray(source)) {
                destination &#x3D; new source.constructor(source);
            } else if (Utils.isDate(source)) {
                destination &#x3D; new Date(source.getTime());
            } else if (Utils.isRegExp(source)) {
                const matches &#x3D; source.toString().match(/[^\/]*$/);
                destination &#x3D; new RegExp(source.source, matches ? matches[0] : &quot;&quot;);
                destination.lastIndex &#x3D; source.lastIndex;
            } else if (Utils.isFunction(source.cloneNode)) {
                destination &#x3D; source.cloneNode(true);
            } else {
                destination &#x3D; Object.create(Object.getPrototypeOf(source));
                needsRecurse &#x3D; true;
            }

            stackSource.push(source);
            stackDest.push(destination);

            return needsRecurse ? copyRecurse(source, destination) : destination;
        }
    }

    // Not currently used
    private static copyWithoutNullOrEmpty(dst: MapOf&lt;any&gt;, src: MapOf&lt;any&gt;): MapOf&lt;any&gt; {
        const keys &#x3D; Object.keys(src);
        for (let j &#x3D; 0, jj &#x3D; keys.length; j &lt; jj; j++) {
            const key &#x3D; keys[j];
            const value &#x3D; src[key];
            if (value &#x3D;&#x3D;&#x3D; null || Utils.isEmpty(null)) {
                continue;
            }
            else if (Utils.isObject(value)) {
                if (Utils.isDate(value)) {
                    dst[key] &#x3D; new Date(value.valueOf());
                }
                else if (Utils.isRegExp(value)) {
                    dst[key] &#x3D; new RegExp(value);
                }
                else {
                    if (!Utils.isObject(dst[key])) {
                        dst[key] &#x3D; Utils.isArray(value) ? [] : {};
                    }
                    dst[key] &#x3D; Utils.copyWithoutNullOrEmpty(dst[key], value);
                }
            }
            else {
                dst[key] &#x3D; value;
            }
        }
        return dst;
    }

    /**
     * Makes a shallow copy of the passed object. Empty string values are removed from the copied object.
     * A string value containing &#x60;&quot;&quot;&#x60; is copied as an empty string.
     *
     * @param defaults The object to copy
     * @return The copied object
     */
    static copyDefaults(defaults: {}): {} {
        const _defaults &#x3D; Utils.copy(defaults);
        if (_defaults) {
            Object.keys(_defaults).forEach(key &#x3D;&gt; {
                // Unset parameters will come through as empty strings (regardless of type)
                // Filter these out (to not hide defaults on the server) and accept &quot;&quot; as a way of explicitly
                // setting a parameter to be an empty string
                const value &#x3D; _defaults[key];
                if (value &#x3D;&#x3D;&#x3D; &quot;&quot;) {
                    delete _defaults[key];
                }
                if (value &#x3D;&#x3D;&#x3D; &quot;\&quot;\&quot;&quot;) {
                    _defaults[key] &#x3D; &quot;&quot;;
                }
            });
        }
        return _defaults;
    }

    /**
     * Performs an optimized deep comparison between two objects to determine if they should be considered equal
     * @param o1 The first object to be compared
     * @param o2 The second object to be compared
     */
    static equals(o1: any, o2:any): boolean {
        return isEqual(o1, o2);
    }

    /**
     * Converts a string to an integer value using &#x60;parseInt&#x60; with radix &#x3D; 10.
     * If the string cannot be converted or contains additional characters then the
     * passed default value is returned
     * @param str The string to convert
     * @param _default The default value to use if the string cannot be converted
     */
    static toInt(str: string, _default: number &#x3D; 0): number {
        let value &#x3D; parseInt(str, 10);
        if (isNaN(value) || (value + &quot;&quot; !&#x3D;&#x3D; str)) {
            value &#x3D; _default;
        }
        return value;
    }

    /**
     * Converts a string to a floating point value using &#x60;parseFloat&#x60;.
     * If the string cannot be converted then the passed default value is returned
     * @param str The string to convert
     * @param _default The default value to use if the string cannot be converted
     */
    static toNumber(str: string, _default: number &#x3D; 0): number {
        let value &#x3D; parseFloat(str);
        if (isNaN(value)) {
            value &#x3D; _default;
        }
        return value;
    }

    /**
     * Converts a string to a &#x60;Date&#x60; using &#x60;Date.parse&#x60;.
     * The date is returned in UTC. If the string cannot be converted then &#x60;undefined&#x60; is returned
     * @param str The string to convert
     * @return The converted &#x60;Date&#x60; in UTC or &#x60;undefined&#x60;
     */
    static toDate(str: string): Date | undefined {
        const ms &#x3D; Date.parse(str);
        if (!ms &amp;&amp; ms !&#x3D;&#x3D; 0) {
            return undefined;
        }
        return new Date(ms + new Date(ms).getTimezoneOffset() * 60000); // get date in UTC
    }

    /**
     * Get the time component of a &#x60;Date&#x60; in milliseconds
     *
     * @param date The date
     * @return The time in milliseconds
     */
    static getTime(date: Date): number {
        if (!date) {
            return 0;
        }
        return (date.getHours() * 60 * 60 + date.getMinutes() * 60 + date.getSeconds()) * 1000 + date.getMilliseconds();
    }

    /**
     * Return the current date and time
     */
    static get now(): Date {
        return new Date();
    }

    /**
     * Converts a &#x60;Date&#x60; to a Sinequa system date string (&#x60;dd-mm-yyyy[ hh:mm:ss]&#x60;)
     * If the time component of the date is 0 then only the date portion of the string is included
     *
     * @param date The &#x60;Date&#x60; to convert
     */
    static toSysDateStr(date: Date): string {
        if (!date)  {
            return &quot;&quot;;
        }
        const m &#x3D; moment(date);
        if (Utils.getTime(date) &#x3D;&#x3D;&#x3D; 0) {
            return m.format(&quot;YYYY-MM-DD&quot;);
        }
        else {
            return m.format(&quot;YYYY-MM-DD HH:mm:ss&quot;);
        }
    }

    /**
     * Converts a Sinequa system date string (&#x60;dd-mm-yyyy[ hh:mm:ss]&#x60;) to a &#x60;Date&#x60;
     * If the string cannot be converted then &#x60;undefined&#x60; is returned
     *
     * @param date The Sinequa system date string to convert
     */
    static fromSysDateStr(value: string): Date | undefined {
        const m &#x3D; moment(value, &quot;YYYY-MM-DD HH:mm:ss&quot;);
        if (m.isValid()) {
            return m.toDate();
        }
        return undefined;
    }

    private static rxSysDateTime &#x3D; /^\d{4}-(?:0[1-9]|1[012])-(?:0[1-9]|[12][0-9]|3[01])(?: (?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d)?$/;
    // private static rxISO8601 &#x3D; /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    // ISO8601 combined date and time
    private static rxISO8601DateTime &#x3D; /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;

    private static isSysDateTime(str: string): boolean {
        return Utils.rxSysDateTime.test(str);
    }

    private static isISO8601DateTime(str: string): boolean {
        return Utils.rxISO8601DateTime.test(str);
    }

    /**
     * Converts a Javascript value to a JSON string using &#x60;JSON.stringify&#x60;.
     * Date objects are converted to Sinequa system strings
     *
     * @param value The value to convert
     * @param options Options for the conversion. The default is &#x60;{pretty: false}&#x60;
     */
    static toJson(value: any, options: ToJsonOptions &#x3D; {pretty: false}): string {
        return JSON.stringify(value,
            function(key: string, value: any): any  {
                if (key &amp;&amp; Utils.isDate(this[key])) {
                    const str &#x3D; Utils.toSysDateStr(this[key]);
                    return str;
                }
                return value;
            }, options.pretty ? 2 : 0);
    }

    /**
     * Converts a string to an object using &#x60;JSON.parse&#x60;.
     * Strings that are either in Sinequa system date or ISO8601 format are converted to
     * &#x60;Date&#x60; objects if the &#x60;reviveDates&#x60; option is specified.
     *
     * @param str The string to convert
     * @param options Options for the conversion. The default is &#x60;{reviveDates: false}&#x60;
     */
    static fromJson(str: string, options: FromJsonOptions &#x3D; {reviveDates: false}): any {
        if (!str || typeof str !&#x3D;&#x3D; &quot;string&quot;) {
            return {};
        }
        try {
            return JSON.parse(str, options.reviveDates ?
                (key, value) &#x3D;&gt; {
                    if (options.reviveDates &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &quot;string&quot;) {
                        if (Utils.isSysDateTime(value)) {
                            const m &#x3D; moment(value, &quot;YYYY-MM-DD HH:mm:ss&quot;);
                            if (m.isValid()) {
                                return m.toDate();
                            }
                        }
                        else if (Utils.isISO8601DateTime(value)) {
                            const m &#x3D; moment(value, moment.ISO_8601);
                            if (m.isValid()) {
                                return m.toDate();
                            }
                        }
                    }
                    return value;
                } : undefined);
        }
        catch (exception) {
            console.log(&quot;Utils.fromJson exception:&quot;, exception);
            return null;
        }
    }

    /**
     * Converts a &#x60;FieldValue&#x60; value to a string compatible with Sinequa&#x27;s SQL syntax.
     * String and &#x60;Date&#x60; values are enclosed in single quotes if the quote parameter is &#x60;true&#x60;
     *
     * @param value The value to convert
     * @param quote If set, the returned string will be enclosed in single quotes for string and &#x60;Date&#x60; values
     */
    static toSqlValue(value: FieldValue, quote?: boolean): string {
        if (Utils.isNumber(value)) {
            return value + &quot;&quot;;
        }
        if (Utils.isDate(value)) {
            if (quote) {
                return &quot;&#x27;&quot; + Utils.toSysDateStr(value) + &quot;&#x27;&quot;;
            }
            else {
                return Utils.toSysDateStr(value);
            }
        }
        if (Utils.isBoolean(value)) {
            return value ? &quot;true&quot; : &quot;false&quot;;
        }
        if (Utils.isArray(value)) {
            const ret: string[] &#x3D; [];
            value.forEach(v &#x3D;&gt; {
                if (ret.length &gt; 0) {
                    ret.push(&quot;,&quot;);
                }
                if (!v) {
                    ret.push(&quot;null&quot;);
                }
                else if (Utils.isString(v)) {
                    ret.push(v);
                }
                else {
                    ret.push(v.display || v.value || &quot;&quot;);
                }
            });
            ret.splice(0, 0, &quot;[&quot;);
            ret.push(&quot;]&quot;);
            return ret.join(&quot;&quot;);
        }
        if (quote) {
            return &quot;&#x27;&quot; + value + &quot;&#x27;&quot;;
        }
        else {
            return value;
        }
    }

    /**
     * Clean a string so it is compatible with values stored in a Sinequa tree type-column.
     * The following operations are performed:
     * * ensure that the string starts and ends with forward slashes
     * * replace tab characters with spaces
     * * replace semi-colons with commas
     * * replace back slashes with forward slashes
     *
     * @param s The string to clean
     */
    static treeClean(s: string): string {
        if (Utils.isEmpty(s)) {
            return s;
        }
        return Utils.addUrl(&quot;/&quot;, Utils.replace(Utils.replace(Utils.replace(s, &quot;\t&quot;, &quot; &quot;), &quot;;&quot;, &quot;,&quot;), &quot;\\&quot;, &quot;/&quot;), &quot;/&quot;);
    }

    /**
     * Return the first node of a Sinequa tree value enclosed in forward slashes
     *
     * @param s A Sinequa tree value
     */
    static treeFirst(s: string): string {
        const parts &#x3D; Utils.split(s, &quot;/&quot;);
        return parts.length &#x3D;&#x3D;&#x3D; 0 ? &quot;&quot; : &#x60;/${parts[0]}/&#x60;;
    }

    /**
     * Return the first node of a Sinequa tree value
     *
     * @param s A Sinequa tree value
     */
    static treeFirstNode(s: string): string {
        const parts &#x3D; Utils.split(s, &quot;/&quot;);
        return parts[0];
    }

    /**
     * Return the last node of a Sinequa tree value enclosed in forward slashes
     *
     * @param s A Sinequa tree value
     */
    static treeLast(s: string): string {
        const parts &#x3D; Utils.split(s, &quot;/&quot;);
        return parts.length &#x3D;&#x3D;&#x3D; 0 ? &quot;&quot; : &#x60;/${parts[parts.length - 1]}/&#x60;;
    }

    /**
     * Return the last node of a Sinequa tree value
     *
     * @param s A Sinequa tree value
     */
    static treeLastNode(s: string): string {
        const parts &#x3D; Utils.split(s, &quot;/&quot;);
        return parts[parts.length - 1];
    }

    /**
     * Return the nodes making up a Sinequa tree value
     *
     * @param s A Sinequa tree value
     */
    static treeNodes(s: string): string[] {
        return Utils.split(s, &quot;/&quot;);
    }

    /**
     * Return a Sinequa tree value, removing enclosing forward slash characters
     *
     * @param s A Sinequa tree value
     */
    static treeDisplay(s: string): string {
        if (!!s) {
            if (s[0] &#x3D;&#x3D;&#x3D; &quot;/&quot;) {
                s &#x3D; s.substr(1);
            }
            if (s[s.length - 1] &#x3D;&#x3D;&#x3D; &quot;/&quot;) {
                s &#x3D; s.substr(0, s.length - 1);
            }
        }
        return s;
    }

    /**
     * Return the node count of a Sinequa tree value
     *
     * @param s A Sinequa tree value
     */
    static treeCount(s: string): number {
        const count &#x3D; Utils.count(s, &quot;/&quot;);
        return count &gt; 0 ? count - 1 : 0;
    }

    /**
     * Return a pseudo-GUID value using &#x60;Math.random&#x60;
     *
     * @param withHyphens If set, the returned GUID includes hyphen separators
     */
    static guid(withHyphens &#x3D; true): string {
        let d &#x3D; Date.now();
        const guid &#x3D; (withHyphens ?
            &#x27;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#x27; : &#x27;xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx&#x27;).replace(/[xy]/g, (c) &#x3D;&gt; {
                /* tslint:disable:no-bitwise */
                const r &#x3D; (d + Math.random() * 16) % 16 | 0;
                d &#x3D; Math.floor(d / 16);
                return (c &#x3D;&#x3D;&#x3D; &#x27;x&#x27; ? r : (r &amp; 0x3 | 0x8)).toString(16);
                /* tslint:enable:no-bitwise */
            });
        return guid;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is &#x60;undefined&#x60;
     */
    static isUndefined(value): value is undefined {
        return typeof value &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is an &#x60;object&#x60;
     */
    static isObject(value): value is any {
        return value !&#x3D;&#x3D; null &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#x27;object&#x27;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a &#x60;string&#x60;
     */
    static isString(value): value is string {
        return typeof value &#x3D;&#x3D;&#x3D; &#x27;string&#x27;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a &#x60;number&#x60;
     */
    static isNumber(value): value is number {
        return typeof value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a &#x60;boolean&#x60;
     */
    static isBoolean(value): value is boolean {
        return typeof value &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a &#x60;Date&#x60;
     */
    static isDate(value): value is Date {
        return Object.prototype.toString.call(value) &#x3D;&#x3D;&#x3D; &#x27;[object Date]&#x27;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a scalar (&#x60;number&#x60;, &#x60;boolean&#x60; or &#x60;Date&#x60;)
     */
    static isScalar(value): value is number | boolean | Date {
        return Utils.isNumber(value) || Utils.isBoolean(value) || Utils.isDate(value);
    }

    /**
     * Return &#x60;true&#x60; if the passed value is an &#x60;Array&#x60;
     */
    static isArray(value): value is Array&lt;any&gt; {
        return Array.isArray(value);
    }

    /**
     * Return &#x60;true&#x60; if the passed value is iterable
     */
    static isIterable(value): value is Array&lt;any&gt; {
        if (value &#x3D;&#x3D;&#x3D; null || value &#x3D;&#x3D;&#x3D; undefined) {
            return false;
        }
        return typeof value[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a &#x60;Map&#x60;
     */
    static isMap(value): value is Map&lt;any, any&gt; {
        return Object.prototype.toString.call(value) &#x3D;&#x3D;&#x3D; &#x27;[object Map]&#x27;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a &#x60;Function&#x60;
     */
    static isFunction(value): value is Function {
        return typeof value &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a &#x60;RegExp&#x60;
     */
    static isRegExp(value): value is RegExp {
        return Object.prototype.toString.call(value) &#x3D;&#x3D;&#x3D; &#x27;[object RegExp]&#x27;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a &#x60;Window&#x60;
     */
    static isWindow(value): value is Window {
        return value &amp;&amp; value.window &#x3D;&#x3D;&#x3D; value;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a &#x60;File&#x60;
     */
    static isFile(value: any): value is File {
        return Utils.isObject(value) &amp;&amp; Object.prototype.toString.call(value) &#x3D;&#x3D;&#x3D; &quot;[object File]&quot;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a &#x60;FormData&#x60;
     */
    static isFormData(value: any): value is FormData {
        return Utils.isObject(value) &amp;&amp; Object.prototype.toString.call(value) &#x3D;&#x3D;&#x3D; &quot;[object FormData]&quot;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is a &#x60;Blob&#x60;
     */
    static isBlob(value: any): value is Blob {
        return Utils.isObject(value) &amp;&amp; Object.prototype.toString.call(value) &#x3D;&#x3D;&#x3D; &quot;[object Blob]&quot;;
    }

    /**
     * Return &#x60;true&#x60; if the passed value is an &#x60;ArrayBuffer&#x60;
     */
    static isArrayBuffer(value: any): value is ArrayBuffer {
        return Utils.isObject(value) &amp;&amp; Object.prototype.toString.call(value) &#x3D;&#x3D;&#x3D; &quot;[object ArrayBuffer]&quot;;
    }

    private static isArrayLike(obj): boolean {
        // &#x60;null&#x60;, &#x60;undefined&#x60; and &#x60;window&#x60; are not array-like
        if (obj &#x3D;&#x3D; null || Utils.isWindow(obj)) return false;

        // arrays, strings and jQuery/jqLite objects are array like
        // * jqLite is either the jQuery or jqLite constructor function
        // * we have to check the existance of jqLite first as this method is called
        //   via the forEach method when constructing the jqLite object in the first place
        if (Utils.isArray(obj) || Utils.isString(obj) /*|| (jqLite &amp;&amp; obj instanceof jqLite)*/) return true;

        // Support: iOS 8.2 (not reproducible in simulator)
        // &quot;length&quot; in obj used to prevent JIT error (gh-11508)
        const length &#x3D; &quot;length&quot; in Object(obj) &amp;&amp; obj.length;

        // NodeList objects (with &#x60;item&#x60; method) and
        // other objects with suitable length characteristics are array-like
        return Utils.isNumber(length) &amp;&amp;
            (length &gt;&#x3D; 0 &amp;&amp; (length - 1) in obj || typeof obj.item &#x3D;&#x3D;&#x3D; &#x27;function&#x27;);
    }

    /**
     * Return &#x60;true&#x60; if the passed value is an &#x60;object&#x60; without a prototype
     */
    static isBlankObject(value): value is object {
        return value !&#x3D;&#x3D; null &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; !Object.getPrototypeOf(value);
    }

    private static TYPED_ARRAY_REGEXP &#x3D; /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
    /**
     * Return true if the passed value is a &#x60;TypedArray&#x60;
     */
    static isTypedArray(value) {
        return value &amp;&amp; Utils.isNumber(value.length) &amp;&amp; Utils.TYPED_ARRAY_REGEXP.test(Object.prototype.toString.call(value));
    }

    /**
     * Return a promise that is a resolved after a specified amount of time
     *
     * @param ms The time to delay in milliseconds
     */
    static delay(ms: number &#x3D; 0): Promise&lt;void&gt; {
        return new Promise&lt;void&gt;((resolve, reject) &#x3D;&gt; {
            window.setTimeout(() &#x3D;&gt; {
                resolve();
            }, ms);
        });
    }

    /**
     *
     * @param value
     * @param _default
     */
    static isTrue(
        value,
        _default?: boolean): boolean {
        if (typeof (value) &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
            value &#x3D; value.toLowerCase();
        }
        switch (value) {
            case true:
            case &quot;true&quot;:
            case 1:
            case &quot;1&quot;:
            case &quot;on&quot;:
            case &quot;yes&quot;:
                return true;
            case &quot;&quot;:
            case undefined:
                return !!_default;
            default:
                return false;
        }
    }

    /**
     * Compares two strings using the current locale. The return value is negative
     * if &#x60;a&#x60; comes before &#x60;b&#x60; and positive if &#x60;a&#x60; comes after &#x60;b&#x60;. If the values
     * are equal then &#x60;0&#x60; is returned
     *
     * @param a The first string
     * @param b The second string
     * @param ignoreCase If set, do a case-insensitive comparison
     */
    static compare(a: string, b: string, ignoreCase: boolean &#x3D; true): number {
        a &#x3D; a || &#x27;&#x27;;
        b &#x3D; b || &#x27;&#x27;;
        if (ignoreCase) {
            a &#x3D; a.toLocaleUpperCase();
            b &#x3D; b.toLocaleUpperCase();
        }
        return a.localeCompare(b);
    }

    /**
     * Return &#x60;true&#x60; if two strings are equal, respecting case
     *
     * @param a The first string
     * @param b The second string
     */
    static eq(a: string, b: string): boolean {
        return Utils.compare(a, b, false) &#x3D;&#x3D;&#x3D; 0;
    }

    /**
     * Return &#x60;true&#x60; if two strings are equal, ignoring case
     *
     * @param a The first string
     * @param b The second string
     */
    static eqNC(a: string, b: string): boolean {
        return Utils.compare(a, b, true) &#x3D;&#x3D;&#x3D; 0;
    }

    /**
     * Return &#x60;true&#x60; if a number of strings are equal, ignoring case
     *
     * @param a The first string
     * @param b Remaining strings
     */
    static eqNCN(a: string, ...b: string[]) {
        if (!b) {
            return false;
        }
        for (const s of b) {
            if (Utils.eqNC(a, s)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Return the length of a string. If the string is empty (&#x60;null&#x60; or &#x60;undefined&#x60;)
     * @param s A string
     */
    static len(s: string) {
        return (s || &#x27;&#x27;).length;
    }

    /**
     * Return &#x60;true&#x60; if a string starts with another
     *
     * @param a The string to test
     * @param b The prefix
     * @param ignoreCase If &#x60;true&#x60; then ignore case
     */
    static startsWith(a: string, b: string, ignoreCase: boolean &#x3D; true): boolean {
        a &#x3D; a || &#x27;&#x27;;
        b &#x3D; b || &#x27;&#x27;;
        if (ignoreCase) {
            a &#x3D; a.toLocaleUpperCase();
            b &#x3D; b.toLocaleUpperCase();
        }
        return a.startsWith(b);
    }

    /**
     * Return &#x60;true&#x60; if a string ends with another
     *
     * @param a The string to test
     * @param b The postfix
     * @param ignoreCase If &#x60;true&#x60; then ignore case
     */
    static endsWith(a: string, b: string, ignoreCase: boolean &#x3D; true): boolean {
        a &#x3D; a || &#x27;&#x27;;
        b &#x3D; b || &#x27;&#x27;;
        if (ignoreCase) {
            a &#x3D; a.toLocaleUpperCase();
            b &#x3D; b.toLocaleUpperCase();
        }
        return a.endsWith(b);
    }

    /**
     * Return &#x60;true&#x60; if a string is a substring of another
     * @param a The string to test
     * @param b The substring
     * @param ignoreCase If &#x60;true&#x60; then ignore case
     */
    static includes(a: string, b: string, ignoreCase: boolean &#x3D; true): boolean {
        a &#x3D; a || &#x27;&#x27;;
        b &#x3D; b || &#x27;&#x27;;
        if (ignoreCase) {
            a &#x3D; a.toLocaleUpperCase();
            b &#x3D; b.toLocaleUpperCase();
        }
        return a.includes(b);
    }

    /**
     * Return the upper case value of a string using the current locale
     */
    static toUpperCase(s: string): string {
        if (s) {
            return s.toLocaleUpperCase();
        }
        return &quot;&quot;;
    }

    /**
     * Return a string with the first character converted to upper case using the current locale
     */
    static toUpperFirst(s: string): string {
        if (s) {
            return s[0].toLocaleUpperCase() + s.substr(1);
        }
        return &quot;&quot;;
    }

    /**
     * Return the lower case value of a string using the current locale
     */
    static toLowerCase(s: string): string {
        if (s) {
            return s.toLocaleLowerCase();
        }
        return &quot;&quot;;
    }

    /**
     * Return a string with the first character converted to lower case using the current locale
     */
    static toLowerFirst(s: string): string {
        if (s) {
            return s[0].toLocaleLowerCase() + s.substr(1);
        }
        return &quot;&quot;;
    }

    /**
     * Return a string where the first character of each space separated word is converted to upper case.
     * However, if a word contains a full stop character the first character is left unchanged
     */
    static toStartCase(text: string): string {
        if (text) {
            const words &#x3D; text.split(/[\s]+/);
            return words.map(value &#x3D;&gt; !value.includes(&quot;.&quot;) ? Utils.toUpperFirst(value) : value).join(&quot; &quot;);
        }
        return &quot;&quot;;
    }

    /**
     * Return a string where any leading and trailing whitespace characters are removed
     */
    static trim(s: string): string {
        if (s) {
            return s.trim();
        }
        return &quot;&quot;;
    }

    /**
     * Return a string where any leading whitespace characters are removed
     */
    static trimStart(s: string): string {
        if (s) {
            return s.trimStart();
        }
        return &quot;&quot;;
    }

    /**
     * Return a string where any trailing whitespace characters are removed
     */
    static trimEnd(s: string): string {
        if (s) {
            return s.trimEnd();
        }
        return &quot;&quot;;
    }

    /**
     * Return a string truncated to a maximum length. If the length of the string is greater than &#x60;maxLength&#x60;
     * then it is truncated to &#x60;maxLength and a &#x60;suffix&#x60; appended. Otherwise the string is returned unchanged
     *
     * @param s The string to truncate
     * @param maxLength The maximum length
     * @param suffix The value to append if the string is truncated. The default is &#x60;...&#x60;
     */
    static truncate(s: string, maxLength: number, suffix?: string): string {
        if (!s) {
            return &quot;&quot;;
        }
        suffix &#x3D; suffix || &quot;...&quot;;
        if (s.length &lt;&#x3D; maxLength) {
            return s;
        }
        return s.substring(0, maxLength - suffix.length) + suffix;
    }

    private static regExEscapeRegEx &#x3D; /[-\/\\^$*+?.()|[\]{}]/g;

    /**
     * Return a string where any regular expresion operators are escaped
     */
    static regExEscape(s: string): string {
        if (!s) {
            return &quot;&quot;;
        }
        return s.replace(Utils.regExEscapeRegEx, &quot;\\$&amp;&quot;);
    }

    /**
     * Replaces patterns in a string with a replacement string. The pattern can either a string
     * or a &#x60;RegExp&#x60;.
     *
     * @param s The string in which to search for a pattern
     * @param pattern The pattern
     * @param replacement The replacement string to replace any occurrences of the pattern in the string
     */
    static replace(s: string, pattern: string | RegExp, replacement: string): string {
        if (!s || !pattern) {
            return &quot;&quot;;
        }
        if (Utils.isRegExp(pattern)) {
            return s.replace(pattern, replacement);
        }
        else {
            return s.replace(new RegExp(Utils.regExEscape(pattern), &quot;g&quot;), replacement);
        }
    }

    /**
     * Split a string into an array of substrings using the passed separators
     *
     * @param s The string to split
     * @param separators One or more separators
     * @param trim If &#x60;true&#x60; trim any leading and trailing spaces from the substrings
     * @param removeEmpty If &#x60;true&#x60; exclude any empty strings from the array of substrings
     */
    static split(s: string, separators: string | string[], trim &#x3D; true, removeEmpty &#x3D; true): string[] {
        if (!s) {
            return [];
        }
        if (!separators) {
            return [s];
        }
        let split: string[];
        if (typeof separators &#x3D;&#x3D;&#x3D; &quot;string&quot;) {
            split &#x3D; s.split(separators);
            if (trim) {
                split &#x3D; split.map(value &#x3D;&gt; value.trim());
            }
        }
        else {
            let rxs &#x3D; separators.map((value) &#x3D;&gt; Utils.regExEscape(value)).join(&quot;|&quot;);
            if (trim) {
                rxs &#x3D; &quot;(?:^\\s*)|(?:\\s*(?:&quot; + rxs + &quot;)\\s*)|(?:\\s*$)&quot;;
            }
            split &#x3D; s.split(new RegExp(rxs));
        }
        if (removeEmpty) {
            split &#x3D; split.filter((value) &#x3D;&gt; {
                return !Utils.isEmpty(value);
            });
        }
        return split;
    }

    /**
     * Return a string in kebab case (&#x60;CatDog &#x3D;&gt; cat-dog&#x60;)
     */
    static toKebabCase(text: string): string {
        return kebabCase(text);
    }

    /**
     * Return a string in snake case (&#x60;CatDog &#x3D;&gt; cat_dog&#x60;)
     */
    static toSnakeCase(text: string): string {
        return snakeCase(text);
    }

    /**
     * Return a string in camel case (&#x60;CatDog &#x3D;&gt; catDog&#x60;)
     */
    static toCamelCase(text: string): string {
        return camelCase(text);
    }

    /**
     * Return a string with any diacritics removed
     */
    static removeAccents(text: string): string {
        if (!text) {
            return &quot;&quot;;
        }
        return removeDiacritics(text);
    }

    /**
     * Return a string in normalized form which can be used to match entity values. A normalized value
     * has any diacritics removed and is converted to upper case
     */
    static normalize(text: string | null | undefined): string {
        if (!text) {
            return &quot;&quot;;
        }
        return Utils.removeAccents(text).toUpperCase();
    }

    /**
     * Return &#x60;true&#x60; if a string is valid as a simple value for the Sinequa admininistration
     */
    static isValidSimpleName(name: string): boolean {
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);
    }

    /**
     * Return &#x60;true&#x60; if a string is valid as a scoped (&#x60;.&#x60; separated) simple value for the Sinequa admininistration
     */
    static isValidScopedSimpleName(name: string): boolean {
        return /^[a-zA-Z_]([\.]?[a-zA-Z0-9_]+)*$/.test(name);
    }

    /**
     * Return &#x60;true&#x60; if a value is &#x60;null&#x60;, &#x60;undefined&#x60; or &#x60;&quot;&quot;&#x60;
     */
    static isEmpty(value: any): boolean {
        if (value &#x3D;&#x3D;&#x3D; &quot;&quot;) {
            return true;
        }
        if (value &#x3D;&#x3D;&#x3D; null) {
            return true;
        }
        if (Utils.isUndefined(value)) {
            return true;
        }
        return false;
    }

    /**
     * Return the number of occurrences of a substring in a string
     *
     * @param text The text to test
     * @param sub The substring
     * @param ignoreCase If &#x60;true&#x60; don&#x27;t respect case when matching the substring
     */
    static count(text: string, sub: string, ignoreCase &#x3D; true): number {
        if (!text || !sub) {
            return 0;
        }
        if (ignoreCase) {
            text &#x3D; text.toLocaleUpperCase();
            sub &#x3D; sub.toLocaleUpperCase();
        }
        let pos &#x3D; -1;
        let count &#x3D; 0;
        while (true) {
            pos &#x3D; text.indexOf(sub, pos + 1);
            if (pos &#x3D;&#x3D;&#x3D; -1) {
                break;
            }
            count++;
        }
        return count;
    }

    /**
     * Return a string converted to base64
     */
    static toBase64(value: string): string {
        return btoa(encodeURIComponent(value).replace(/%([0-9A-F]{2})/g, (match, hex) &#x3D;&gt; String.fromCharCode(parseInt(hex, 16))));
    }

    /**
     * Return a string converted from base64
     */
    static fromBase64(value: string): string {
        return decodeURIComponent(atob(value).split(&#x27;&#x27;).map((c) &#x3D;&gt; &#x27;%&#x27; + (&#x27;00&#x27; + c.charCodeAt(0).toString(16)).slice(-2)).join(&#x27;&#x27;));
    }

    /**
     * Return the SHA256 hash value of string
     */
    static sha256(value: string): string {
        const sha &#x3D; new jsSHA(&quot;SHA-256&quot;, &quot;TEXT&quot;);
        sha.update(value);
        return sha.getHash(&quot;B64&quot;);
    }

    /**
     * Return the SHA512 hash value of string
     */
    static sha512(value: string): string {
        const sha &#x3D; new jsSHA(&quot;SHA-512&quot;, &quot;TEXT&quot;);
        sha.update(value);
        return sha.getHash(&quot;B64&quot;);
    }

    /**
     * Return a string where any HTML special characters are percent encoded
     */
    static encodeHTML(value: string): string {
        return escape(value);
    }

    /**
     * Return a string where any percent encoded characters are replaced by their corresponding unencoded characters
     */
    static decodeHTML(value: string): string {
        return unescape(value);
    }

    /**
     * Get a field with passed name from an object. The field name is matched insensitive of case
     */
    static getField&lt;T&gt;(obj: MapOf&lt;T&gt;, name: string): T | undefined {
        if (!Utils.isObject(obj) || Utils.isEmpty(name)) {
            return undefined;
        }
        const keys &#x3D; Object.keys(obj).filter(key &#x3D;&gt; Utils.eqNC(key, name));
        if (keys.length &#x3D;&#x3D;&#x3D; 0) {
            return undefined;
        }
        return obj[keys[0]];
    }

    /**
     * Clear fields from an object. If the &#x60;_delete&#x60; parameter is &#x60;false&#x60; then
     * array or map fields are emptied and other fields are set to &#x60;undefined&#x60;.
     * If the &#x60;_delete&#x60; parameter is &#x60;true&#x60; then fields are deleted
     */
    static clearObject(obj: {}, _delete: boolean &#x3D; false): {} {
        for (const prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                if (_delete) {
                    delete obj[prop];
                }
                else {
                    if (Utils.isArray(obj[prop])) {
                        obj[prop].length &#x3D; 0;
                    }
                    else if (Utils.isMap(obj[prop])) {
                        obj[prop].clear();
                    }
                    else {
                        obj[prop] &#x3D; undefined;
                    }
                }
            }
        }
        return obj;
    }

    /**
     * Return the non-empty fields in the &#x60;override&#x60; object that that are different to fields of the same name
     * in the &#x60;template&#x60; object
     * @param template The object to compare against
     * @param override The object defining the fields and values to be compared
     * @param ret An optional return object. If not set a new object is created
     */
    static deltas(template: {}, override: {}, ret?: {}): {} {
        if (!ret) {
            ret &#x3D; {};
        }
        for (const name of Object.keys(override)) {
            if (name in template) {
                if (Utils.isObject(override[name]) &amp;&amp; !Utils.isArray(override[name])) {
                    const diff &#x3D; Utils.deltas(template[name], override[name]);
                    if (!Utils.equals(diff, {})) {
                        ret[name] &#x3D; diff;
                    }
                }
                else if (!Utils.equals(template[name], override[name])) {
                    if (!Utils.isEmpty(override[name])) {
                        ret[name] &#x3D; override[name];
                    }
                }
            }
            else {
                if (!Utils.isEmpty(override[name])) {
                    ret[name] &#x3D; override[name];
                }
            }
        }
        return ret;
    }

    /**
     * Returns an object containing the fields in a source object whose names match one of the passed keys. The keys can either be
     * an array of strings or a callback function that is called for each field in the source object and returns &#x60;true&#x60; if a field
     * should be &quot;picked&quot;.
     *
     * @param obj The source object
     * @param keys An array of keys or a callback function
     */
    static pick(obj: {}, keys: string[] | ((value: any, key: string, obj: object) &#x3D;&gt; boolean)): {} {
        const ret &#x3D; {};
        if (!!obj) {
            if (Utils.isFunction(keys)) {
                Object.keys(obj).forEach(key &#x3D;&gt; {
                    if (keys(obj[key], key, obj)) {
                        ret[key] &#x3D; obj[key];
                    }
                });
            }
            else {
                for (const key of keys) {
                    if (obj.hasOwnProperty(key)) {
                        ret[key] &#x3D; obj[key];
                    }
                }
            }
        }
        return ret;
    }

    /**
     * Create a debounce function that delays invoking &#x60;func&#x60; until after &#x60;wait&#x60; millseconds have elapsed since the previous invocation.
     *
     * @param func The function to debounce
     * @param wait The delay in milliseconds to wait before calling &#x60;func&#x60;
     * @param immediate If &#x60;true&#x60; then make an initial call to &#x60;func&#x60;
     * @param every An optional callback to call without debouncing
     */
    static debounce(func: (...params) &#x3D;&gt; any, wait &#x3D; 0, immediate &#x3D; false, every?: (...params) &#x3D;&gt; any): (...params) &#x3D;&gt; any {
        let timeout, args, context, timestamp, result;

        const later &#x3D; function() {
            const last &#x3D; Date.now() - timestamp;

            if (last &lt; wait &amp;&amp; last &gt;&#x3D; 0) {
                timeout &#x3D; setTimeout(later, wait - last);
            }
            else {
                timeout &#x3D; null;
                if (!immediate) {
                    result &#x3D; func.apply(context, args);
                    if (!timeout) {
                        context &#x3D; args &#x3D; null;
                    }
                }
            }
        };

        return function(this: any) {
            context &#x3D; this;
            args &#x3D; arguments;
            if (every) {
                every.apply(context, args);
            }
            timestamp &#x3D; Date.now();
            const callNow &#x3D; immediate &amp;&amp; !timeout;
            if (!timeout) {
                timeout &#x3D; setTimeout(later, wait);
            }
            if (callNow) {
                result &#x3D; func.apply(context, args);
                context &#x3D; args &#x3D; null;
            }

            return result;
        };
    }

    /**
     * Create a throttled function that only invokes func at most once per every &#x60;wait&#x60; milliseconds.
     *
     * @param func The function to throttle
     * @param wait The number of milliseconds to throttle invocations to
     * @param options Options to control the throttling behaviour
     */
    static throttle(func: (...params) &#x3D;&gt; any, wait: number, options: ThrottleSettings &#x3D; {}): (...pararms) &#x3D;&gt; any {
        let timeout, context, args, result;
        let previous &#x3D; 0;

        const later &#x3D; function() {
            previous &#x3D; options.leading &#x3D;&#x3D;&#x3D; false ? 0 : Date.now();
            timeout &#x3D; null;
            result &#x3D; func.apply(context, args);
            if (!timeout) context &#x3D; args &#x3D; null;
        };

        const throttled &#x3D; function(this: any) {
            const now &#x3D; Date.now();
            if (!previous &amp;&amp; options.leading &#x3D;&#x3D;&#x3D; false) previous &#x3D; now;
            const remaining &#x3D; wait - (now - previous);
            context &#x3D; this;
            args &#x3D; arguments;
            if (remaining &lt;&#x3D; 0 || remaining &gt; wait) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout &#x3D; null;
                }
                previous &#x3D; now;
                result &#x3D; func.apply(context, args);
                if (!timeout) context &#x3D; args &#x3D; null;
            }
            else if (!timeout &amp;&amp; options.trailing !&#x3D;&#x3D; false) {
                timeout &#x3D; setTimeout(later, remaining);
            }
            return result;
        };

        throttled[&quot;cancel&quot;] &#x3D; function() {
            clearTimeout(timeout);
            previous &#x3D; 0;
            timeout &#x3D; context &#x3D; args &#x3D; null;
        };

        return throttled;
    }

    private static frameTasks: Map&lt;(...params) &#x3D;&gt; any, FrameTask&gt; &#x3D; new Map&lt;(...params) &#x3D;&gt; any, FrameTask&gt;();

    /**
     * Create a function that calls &#x60;callback&#x60; the next time the browser next repaints
     */
    static frame(callback: (...params) &#x3D;&gt; any): (...params) &#x3D;&gt; any {
        return (...params) &#x3D;&gt; {
            if (Utils.frameTasks.size &#x3D;&#x3D;&#x3D; 0) {
                requestAnimationFrame((timestamp) &#x3D;&gt; {
                    Utils.frameTasks.forEach((task, key, map) &#x3D;&gt; {
                        task.call();
                    });
                    Utils.frameTasks.clear();
                });
            }
            const task &#x3D; Utils.frameTasks.get(callback);
            if (task) {
                // Update params
                task.params &#x3D; params;
            }
            else {
                // Add new task
                Utils.frameTasks.set(callback, new FrameTask(callback, params));
            }
        };
    }

    /**
     * Create a URL object from a &#x60;url&#x60; string. If the string is a relative url then
     * &#x60;base&#x60; specifies the base to use
     */
    static makeURL(url: string, base?: string): URL {
        if (!base) {
            base &#x3D; &quot;http://x.y.z&quot;; // Firefox and IOS need this
        }
        return new URL(url, base);
    }

    /**
     * Add query string parameters to a url
     *
     * @param url The url to which to add the parameters
     * @param params An object whose fields should be added as parameters
     */
    static addSearchParams(url: string, params: MapOf&lt;any&gt;): string {
        if (!url || !params) {
            return url;
        }
        const urlObj &#x3D; Utils.makeURL(url);
        for (const param in params) {
            if (params.hasOwnProperty(param)) {
                urlObj.searchParams.set(param, params[param]);
            }
        }
        const index &#x3D; url.indexOf(&quot;?&quot;);
        if (index !&#x3D;&#x3D; -1) {
            url &#x3D; url.substr(0, index);
        }
        url +&#x3D; &quot;?&quot; + urlObj.searchParams.toString();
        return url;
    }

    private static _addUrl(url: string, path: string): string {
        if (!path) {
            return url;
        }
        if (!url) {
            return path;
        }
        if (url[url.length - 1] &#x3D;&#x3D;&#x3D; &quot;/&quot;) {
            if (path[0] &#x3D;&#x3D;&#x3D; &quot;/&quot;) {
                return url + path.substr(1);
            }
            else {
                return url + path;
            }
        }
        else {
            if (path[0] &#x3D;&#x3D;&#x3D; &quot;/&quot;) {
                return url + path;
            }
            else {
                return url + &quot;/&quot; + path;
            }
        }
    }

    /**
     * Add paths to a url adding path separators as necessary
     *
     * @param url The url
     * @param paths One or more paths to add to the url
     */
    static addUrl(url: string, ...paths: string[]): string {
        let _url &#x3D; url;
        for (const path of paths) {
            _url &#x3D; Utils._addUrl(_url, path);
        }
        return _url;
    }

    /**
     * Return &#x60;true&#x60; if a url is absolute
     */
    static isUrlAbsolute(url: string): boolean {
        return /^(?:[a-zA-Z][a-zA-Z\d+.-]*:|\/\/)/.test(url);
    }

    /**
     * Return an &#x60;HttpParams&#x60; object containing the fields in the passed object
     */
    static makeHttpParams(params: MapOf&lt;string | boolean | number | Date | object | undefined&gt;): HttpParams {
        let httpParams &#x3D; new HttpParams({encoder: new SqHttpParameterCodec()});
        if (params) {
            for (const param in params) {
                if (params.hasOwnProperty(param)) {
                    const _value &#x3D; params[param];
                    let value &#x3D; &quot;&quot;;
                    if (Utils.isString(_value)) {
                        value &#x3D; _value;
                    }
                    else if (Utils.isBoolean(_value) || Utils.isNumber(_value)) {
                        value &#x3D; _value.toString();
                    }
                    else if (Utils.isDate(_value)) {
                        value &#x3D; Utils.toSysDateStr(_value);
                    }
                    else {
                        value &#x3D; Utils.toJson(_value);
                    }
                    httpParams &#x3D; httpParams.set(param, value);
                }
            }
        }
        return httpParams;
    }

    private static escapeDiv: HTMLElement;

    /**
     * Return a string with HTML special characters escaped
     *
     * @param html The string to escape
     */
    static escapeHtml(html: string): string {
        if (!html) {
            return html;
        }
        if (!Utils.escapeDiv) {
            Utils.escapeDiv &#x3D; document.createElement(&quot;div&quot;);
        }
        const textNode &#x3D; Utils.escapeDiv.appendChild(document.createTextNode(html));
        const escapedHtml &#x3D; Utils.escapeDiv.innerHTML;
        Utils.escapeDiv.removeChild(textNode);
        return escapedHtml;
    }

    /**
     * Move an element in an array
     *
     * @param array The array containing the element to move
     * @param from The index of the element to move
     * @param to The index that the element should be moved to
     */
    static arrayMove(array: any[], from: number, to: number): void {
        if (to &#x3D;&#x3D;&#x3D; from ) {
            return;
        }
        array.splice(to, 0, array.splice(from, 1)[0]);
    }

    /**
     * Set the contents of a target array to the contents of a source array
     *
     * @param target The target array
     * @param source The source array
     */
    static arraySet(target: any[], source: any[]): any[] {
        return target.splice.apply(target, [0, target.length].concat(source));
    }

    private static genericNext(value) {
    }

    private static genericError(error: any) {
    }

    private static genericComplete() {
    }

    /**
     * A simple wrapped around &#x60;Observable.subscribe&#x60;
     */
    static subscribe&lt;T&gt;(
        observable: Observable&lt;T&gt;,
        next: (value: T) &#x3D;&gt; void, error?: (err: any) &#x3D;&gt; void, complete?: () &#x3D;&gt; void): Subscription {
        if (!next) {
            next &#x3D; Utils.genericNext;
        }
        if (!error) {
            error &#x3D; Utils.genericError;
        }
        if (!complete) {
            complete &#x3D; Utils.genericComplete;
        }
        return observable.subscribe(next, error, complete);
    }

    /**
     * Return a value as a &#x60;Date&#x60; converting as necessary. If the value
     * cannot be converted then &#x60;undefined&#x60; is returned
     */
    static asDate(value: any): Date | undefined {
        if (!value) {
            return undefined;
        }

        if (Utils.isDate(value)) {
            return value as Date;
        }

        if (Utils.isString(value)) {
            return Utils.toDate(value as string);
        }

        return undefined;
    }

    /**
     * Return a value as a &#x60;number&#x60; converting as necessary. If the value
     * cannot be converted then &#x60;undefined&#x60; is returned.
     */
    static asNumber(value: any): number | undefined {
        if (!value &amp;&amp; value !&#x3D;&#x3D; 0) {
            return undefined;
        }
        if (Utils.isNumber(value)) {
            return value;
        }
        if (Utils.isString(value)) {
            if (Utils.testInteger(value)) {
                return Utils.toInt(value);
            }
            if (Utils.testFloat(value)) {
                return Utils.toNumber(value);
            }
        }
        return undefined;
    }

    /**
     * Return a value as a &#x60;string&#x60; converting as necessary
     */
    static asString(value: any): string | undefined {
        if (!value &amp;&amp; value !&#x3D;&#x3D; &quot;&quot;) {
            return undefined;
        }

        if (Utils.isString(value)) {
            return value as string;
        }

        return value.toString();
    }

    /**
     * Return &#x60;true&#x60; if a string represents an integer
     */
    static testInteger(str: string): boolean {
        return /^(\-|\+)?([0-9]+)$/.test(str);
    }

    /**
     * Return &#x60;true&#x60; if a string represents a floating point number
     */
    static testFloat(str: string): boolean {
        return /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/.test(str);
    }

    /**
     * Round the passed number away from zero: 4.5 &#x3D;&gt; 5, -4.5 &#x3D;&gt; -5
     */
    static roundAway(num: number): number {
        return num &gt;&#x3D; 0 ? Math.round(num) : Math.sign(num) * Math.round(Math.abs(num));
    }

    private static matchSuffix(str: string, factor: number, ...suffixes: string[]): {str: string, factor: number} | undefined {
        for (const suffix of suffixes) {
            if (Utils.endsWith(str, suffix)) {
                return {
                    str: Utils.trimEnd(str.substr(0, str.length - suffix.length)),
                    factor
                };
            }
        }
        return undefined;
    }

    /**
     * Convert a size in string form to a number in bytes.
     *
     * The following units are supported: &#x60;b&#x60;, &#x60;kb&#x60;, &#x60;mb&#x60;, &#x60;gb&#x60;, &#x60;tb&#x60;, &#x60;pb&#x60;
     *
     * For example &#x60;2.5 gb&#x60; will return &#x60;2621440&#x60;.
     */
    static toSize(str: string, _default &#x3D; 0): number {
        str &#x3D; Utils.trim(str);
        if (!str) {
            return _default;
        }
        let factor &#x3D; 1;
        let ret &#x3D; Utils.matchSuffix(str, 1024 * 1024 * 1024 * 1024 * 1024, &quot;PB&quot;, &quot;PO&quot;);
        if (ret &#x3D;&#x3D;&#x3D; undefined) {
            ret &#x3D; Utils.matchSuffix(str, 1024 * 1024 * 1024 * 1024, &quot;TB&quot;, &quot;TO&quot;);
        }
        if (ret &#x3D;&#x3D;&#x3D; undefined) {
            ret &#x3D; Utils.matchSuffix(str, 1024 * 1024 * 1024, &quot;GB&quot;, &quot;GO&quot;);
        }
        if (ret &#x3D;&#x3D;&#x3D; undefined) {
            ret &#x3D; Utils.matchSuffix(str, 1024 * 1024, &quot;MB&quot;, &quot;MO&quot;);
        }
        if (ret &#x3D;&#x3D;&#x3D; undefined) {
            ret &#x3D; Utils.matchSuffix(str, 1024, &quot;KB&quot;, &quot;KO&quot;);
        }
        if (ret &#x3D;&#x3D;&#x3D; undefined) {
            ret &#x3D; Utils.matchSuffix(str, 1, &quot;B&quot;, &quot;O&quot;);
        }
        if (ret !&#x3D;&#x3D; undefined) {
            str &#x3D; ret.str;
            factor &#x3D; ret.factor;
        }
        if (!Utils.testFloat(str)) {
            return _default;
        }
        const value &#x3D; Utils.toNumber(str, _default) * factor;
        return Math.round(value);
    }

    private static calculateDuration(current: number, unit: string): number {
        switch (Utils.toLowerCase(unit)) {
            case &quot;d&quot;:    case &quot;j&quot;:
            case &quot;days&quot;: case &quot;jours&quot;:
            case &quot;day&quot;:  case &quot;jour&quot;:
                return current * Utils.oneDay;
            case &quot;h&quot;:
            case &quot;hours&quot;: case &quot;heures&quot;:
            case &quot;hour&quot;:  case &quot;heure&quot;:
                return current * Utils.oneHour;
            case &quot;m&quot;:
            case &quot;minutes&quot;: case &quot;minute&quot;:
            case &quot;mins&quot;:    case &quot;min&quot;:
                return current * Utils.oneMinute;
            case &quot;s&quot;:
            case &quot;seconds&quot;:  case &quot;secondes&quot;:
            case &quot;second&quot;:   case &quot;seconde&quot;:
            case &quot;secs&quot;: case &quot;sec&quot;:
                return current * Utils.oneSecond;
                break;
            case &quot;ms&quot;:
            case &quot;milliseconds&quot;: case &quot;miliseconds&quot;:  case &quot;millisecondes&quot;: case &quot;milisecondes&quot;:
            case &quot;millisecond&quot;:  case &quot;milliseconde&quot;: case &quot;milisecond&quot;:    case &quot;miliseconde&quot;:
                return current;
            default:
                return 0;
        }
    }

    /**
     * Convert a duration in string form to a number in milliseconds.
     *
     * These units are supported: &#x60;days&#x60;, &#x60;hours&#x60;, &#x60;minutes&#x60;, &#x60;seconds&#x60;, &#x60;milliseconds&#x60; (abbreviations are also supported)
     *
     * For example &#x60;3 h 2mins 4s &#x3D;&gt; 10924000&#x60;
     *
     * @param defaultUnit The unit to use if no units are in the string. The default value is &#x60;ms&#x60;
     */
    static toDuration(str: string, defaultUnit &#x3D; &quot;ms&quot;): number {
        let total &#x3D; 0;
        if (str) {
            let current &#x3D; 0;
            const tokens &#x3D; str.match(/[0-9\.,]+|[a-zA-Z]+/g) || [];
            for (const token of tokens) {
                if (/[a-zA-Z]/.test(token)) {
                    total +&#x3D; Utils.calculateDuration(current, token);
                    current &#x3D; 0;
                }
                else {
                    if (current) {
                        total +&#x3D; Utils.calculateDuration(current, defaultUnit);
                    }
                    current &#x3D; Utils.toNumber(token);
                }
            }
            if (current) {
                total +&#x3D; Utils.calculateDuration(current, defaultUnit);
            }
        }
        return total;
    }
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'FromJsonOptions.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
